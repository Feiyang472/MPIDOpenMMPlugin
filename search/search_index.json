{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About This OpenMM plugin implements polarizable multipole electrostatics, primarily aimed at supporting the MPID formulation of the CHARMM Drude force field. However, the code is quite general and many features can be compiled on-the-fly, allowing it to tailor features as required without incurring a performance penalty. Supported features include: Particle mesh Ewald electrostatics. Multipoles (up to octopoles). Induced dipoles, with a range of solvers to evaluate them. Isotropic or anisotropic polarizability.","title":"Home"},{"location":"#about","text":"This OpenMM plugin implements polarizable multipole electrostatics, primarily aimed at supporting the MPID formulation of the CHARMM Drude force field. However, the code is quite general and many features can be compiled on-the-fly, allowing it to tailor features as required without incurring a performance penalty. Supported features include: Particle mesh Ewald electrostatics. Multipoles (up to octopoles). Induced dipoles, with a range of solvers to evaluate them. Isotropic or anisotropic polarizability.","title":"About"},{"location":"authors/","text":"The plugin was written by Andrew C. Simmonett at the National Institutes of Health, and was based on the AMOEBA plugin written by Mark Friedrichs and Peter Eastman at Stanford.","title":"Authors"},{"location":"building/","text":"Obtaining the code The plugin is hosted on Github and can be checked out with git clone git@github.com:andysim/MPIDOpenMMPlugin Dependencies The code needs OpenMM version 7.5 or later, which can be installed as follows. Installation of Dependencies via Conda Conda is strongly recommended for managing the environment and dependencies; after downloading anaconda (make sure you use bash or zsh ). To install the 7.5 verion of OpenMM into its own Conda environment called mpid , run conda create -n mpid openmm=7.5 cudatoolkit=10.2 swig mdtraj -c conda-forge Make sure you request the version of the CUDA toolkit supported on your cluster. This example uses GCC to build; the speed of the C++ compiler is irrelevant, because the CUDA code is the only fast code available in this plugin. Although the reference platform will run, it is very slow and designed for correctness. Building the plugin The plugin uses CMake for building, so that should be install locally; it can be obtained from Conda if you do not have it available. Once CMake is installed, you can build the code using commands similar to the following (the exact type of modules and mechanisms to load them will vary from system to system):: conda activate mpid export OPENMM_INSTALL_DIR=~/anaconda3/envs/mpid module load cuda/10.2 module load cmake module load gcc/8.2 # From the MPIDOpenMMPlugin top level directory mkdir build cd build CXX=g++ cmake .. -DCMAKE_INSTALL_PREFIX=$OPENMM_INSTALL_DIR -DPYTHON_EXECUTABLE=`which python` -DOPENMM_DIR=$OPENMM_INSTALL_DIR -DCMAKE_CXX_FLAGS='-std=c++11' make -j 4 make test make install make PythonInstall Note that we use GCC in this example, but the nature of the C++ compiler is not important, as the faster kernels are implemented in CUDA and only the slow reference implementation is available on regular CPUs. Before running the code, make sure you load the conda environment and all modules used for building when using the plugin. conda activate mpid","title":"Installation"},{"location":"building/#obtaining-the-code","text":"The plugin is hosted on Github and can be checked out with git clone git@github.com:andysim/MPIDOpenMMPlugin","title":"Obtaining the code"},{"location":"building/#dependencies","text":"The code needs OpenMM version 7.5 or later, which can be installed as follows.","title":"Dependencies"},{"location":"building/#installation-of-dependencies-via-conda","text":"Conda is strongly recommended for managing the environment and dependencies; after downloading anaconda (make sure you use bash or zsh ). To install the 7.5 verion of OpenMM into its own Conda environment called mpid , run conda create -n mpid openmm=7.5 cudatoolkit=10.2 swig mdtraj -c conda-forge Make sure you request the version of the CUDA toolkit supported on your cluster. This example uses GCC to build; the speed of the C++ compiler is irrelevant, because the CUDA code is the only fast code available in this plugin. Although the reference platform will run, it is very slow and designed for correctness.","title":"Installation of Dependencies via Conda"},{"location":"building/#building-the-plugin","text":"The plugin uses CMake for building, so that should be install locally; it can be obtained from Conda if you do not have it available. Once CMake is installed, you can build the code using commands similar to the following (the exact type of modules and mechanisms to load them will vary from system to system):: conda activate mpid export OPENMM_INSTALL_DIR=~/anaconda3/envs/mpid module load cuda/10.2 module load cmake module load gcc/8.2 # From the MPIDOpenMMPlugin top level directory mkdir build cd build CXX=g++ cmake .. -DCMAKE_INSTALL_PREFIX=$OPENMM_INSTALL_DIR -DPYTHON_EXECUTABLE=`which python` -DOPENMM_DIR=$OPENMM_INSTALL_DIR -DCMAKE_CXX_FLAGS='-std=c++11' make -j 4 make test make install make PythonInstall Note that we use GCC in this example, but the nature of the C++ compiler is not important, as the faster kernels are implemented in CUDA and only the slow reference implementation is available on regular CPUs. Before running the code, make sure you load the conda environment and all modules used for building when using the plugin. conda activate mpid","title":"Building the plugin"},{"location":"contributing/","text":"Contributing The code is fully open source, and contributions are welcome via a pull request on Github. Please open an issue on Github to report any problems.","title":"Contributing"},{"location":"contributing/#contributing","text":"The code is fully open source, and contributions are welcome via a pull request on Github. Please open an issue on Github to report any problems.","title":"Contributing"},{"location":"license/","text":"This plugin is freely distributed under the BSD 3-Clause License: Copyright (c) 2017-2021, Andrew C. Simmonett All rights reserved. Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. * Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.","title":"License"},{"location":"running/","text":"Running the Plugin The following is a brief summary of the simple examples included in the repository. The usage of the plugin follows standard OpenMM practices ] so that would be a good place to start for anybody unfamiliar with OpenMM. Specifying the Parameters Units OpenMM uses the following units: Time: \\(ps\\) Energy: \\(kJ/mol\\) Distance: \\(nm\\) Mass: \\(amu\\) Temperature: \\(K\\) Charge: \\(e\\) Angle: \\(rad\\) This choice ensures that forces obtained from \\(F=ma\\) are consistent with those obtained from \\(F=-\\frac{\\mathrm{d}U}{\\mathrm{d}R}\\) without the need for scale factors. The XML file Parameters should be specified using a standard OpenMM XML file . As an illustrative example, here is the full specification of the MPID implementation of the SWM6 water model: <ForceField> <AtomTypes> <Type name=\"OT\" class=\"OW\" element=\"O\" mass=\"15.999\"/> <Type name=\"HT\" class=\"HW\" element=\"H\" mass=\"1.008\"/> </AtomTypes> <Residues> <Residue name=\"HOH\"> <Atom name=\"H1\" type=\"HT\"/> <Atom name=\"H2\" type=\"HT\"/> <Atom name=\"O\" type=\"OT\"/> <Bond from=\"0\" to=\"2\"/> <Bond from=\"1\" to=\"2\"/> </Residue> </Residues> <HarmonicBondForce> <Bond class1=\"OW\" class2=\"HW\" length=\"0.09572\" k=\"376560\"/> </HarmonicBondForce> <HarmonicAngleForce> <Angle class1=\"HW\" class2=\"OW\" class3=\"HW\" angle=\"1.82421813418\" k=\"460.24\"/> </HarmonicAngleForce> <NonbondedForce coulomb14scale=\"0.833333\" lj14scale=\"0.5\"> <Atom type=\"OT\" charge=\"-0.0\" sigma=\"0.31983264\" epsilon=\"0.677808\"/> <Atom type=\"HT\" charge=\"0.0\" sigma=\"1\" epsilon=\"0\"/> </NonbondedForce> <MPIDForce coulomb14scale=\"0.833333\" defaultTholeWidth=\"8.0\"> <Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" c0=\"-1.0614\" dX=\"0.0\" dY=\"0.0\" dZ=\"-0.023671684\" qXX=\"0.000150963\" qXY=\"0.0\" qYY=\"0.00008707\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"-0.000238034\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.000000426\" oXYZ=\"0.0\" oYYZ=\"0.000000853\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"-0.000001279\" /> <Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" c0=\"0.5307\" dX=\"0.0\" dY=\"0.0\" dZ=\"0.0\" qXX=\"0.0\" qXY=\"0.0\" qYY=\"0.0\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"0.0\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.0\" oXYZ=\"0.0\" oYYZ=\"0.0\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"0.0\" /> <Polarize type=\"OT\" polarizabilityXX=\"0.00088\" polarizabilityYY=\"0.00088\" polarizabilityZZ=\"0.00088\" thole=\"8.0\"/> <Polarize type=\"HT\" polarizabilityXX=\"0.000\" polarizabilityYY=\"0.000\" polarizabilityZZ=\"0.000\" thole=\"0.0\"/> </MPIDForce> </ForceField> Most of this file sets up bonded terms, which are well described in the OpenMM documentation linked above. When defining the NonbondedForce , note that the charges are defined as zero; this is because all electrostatic terms are to be handled by the MPIDForce . The MPIDForce does not handle Lennard-Jones (LJ) terms, so these are still processed by the NonbondedForce , which can also use particle mesh Ewald (PME) to compute the LJ terms effectively without cutoffs. The section defining the MPIDForce terms looks like this: <MPIDForce coulomb14scale=\"0.833333\" defaultTholeWidth=\"8.0\"> <Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" c0=\"-1.0614\" dX=\"0.0\" dY=\"0.0\" dZ=\"-0.023671684\" qXX=\"0.000150963\" qXY=\"0.0\" qYY=\"0.00008707\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"-0.000238034\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.000000426\" oXYZ=\"0.0\" oYYZ=\"0.000000853\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"-0.000001279\" /> <Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" c0=\"0.5307\" dX=\"0.0\" dY=\"0.0\" dZ=\"0.0\" qXX=\"0.0\" qXY=\"0.0\" qYY=\"0.0\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"0.0\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.0\" oXYZ=\"0.0\" oYYZ=\"0.0\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"0.0\" /> <Polarize type=\"OT\" polarizabilityXX=\"0.00088\" polarizabilityYY=\"0.00088\" polarizabilityZZ=\"0.00088\" thole=\"8.0\"/> <Polarize type=\"HT\" polarizabilityXX=\"0.000\" polarizabilityYY=\"0.000\" polarizabilityZZ=\"0.000\" thole=\"0.0\"/> </MPIDForce> The global coulomb14scale parameter controls the scale factor applied to interactions that are topologically three bonds apart, and defaults to 1 (the correct value for MPID) if omitted. The defaultTholeWidth parameter is the [Thole damping] (technical.md#thole-damping) parameter that's applied to particles whose interaction is not neglected due to topological reasons. Multipoles are defined by providing orientation rules, defining their orientation with respect to \"anchor\" atoms within the same system and the syntax follows the conventions used in the AMOEBA force field. For example, Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" defines a multipole on the OT atom, whose z direction is defined as the bisector of the two HT atoms directly connected to it, with the \\(x\\) direction defined by the plane containing both HT . The Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" similarly defines a multipole on HT , whose local z axis is defined by its bond to the OT atom; the \\(x\\) axis is then defined by the plane containing the other HT atom. The c0 entry defines the charge (in \\(e\\) ), while dX defines the \\(x\\) component of the dipole in \\(e/nm\\) , etc. . Multipoles up to octopoles are supported, and any values omitted are assumed to be zero. The Polarize tag is optional and is used to define a given atom as polarizable. The \\(xx\\) , \\(yy\\) and \\(zz\\) elements of the polarizability tensor should be specified individually, in the axis system used to define the multipoles described above. If all three components of the polarizability tensor are equal, the polarizability is isotropic and the orientation rules are irrelevant. The Thole damping parameter, detailed here is a unitless parameter used to dampen topologically excluded interactions between pairs of induced dipoles if the chosen solver considers them. Creating a System With the appropriate XML-formatted force field in hand, setting up a simulation follows the standard OpenMM approach . The createSystem() function from the ForceField class, which is used to build the system obeys all of the usual arguments for controlling constraint algorithms, hydrogen mass repartitioning, cutoffs, etc. . For MPIDForce , the defaultTholeWidth and coulomb14scale arguments may be provided, overriding any values that may be present in the XML parameter file described above. The polarization argument is used to control the polarization solver .","title":"Running the Code"},{"location":"running/#running-the-plugin","text":"The following is a brief summary of the simple examples included in the repository. The usage of the plugin follows standard OpenMM practices ] so that would be a good place to start for anybody unfamiliar with OpenMM.","title":"Running the Plugin"},{"location":"running/#specifying-the-parameters","text":"","title":"Specifying the Parameters"},{"location":"running/#units","text":"OpenMM uses the following units: Time: \\(ps\\) Energy: \\(kJ/mol\\) Distance: \\(nm\\) Mass: \\(amu\\) Temperature: \\(K\\) Charge: \\(e\\) Angle: \\(rad\\) This choice ensures that forces obtained from \\(F=ma\\) are consistent with those obtained from \\(F=-\\frac{\\mathrm{d}U}{\\mathrm{d}R}\\) without the need for scale factors.","title":"Units"},{"location":"running/#the-xml-file","text":"Parameters should be specified using a standard OpenMM XML file . As an illustrative example, here is the full specification of the MPID implementation of the SWM6 water model: <ForceField> <AtomTypes> <Type name=\"OT\" class=\"OW\" element=\"O\" mass=\"15.999\"/> <Type name=\"HT\" class=\"HW\" element=\"H\" mass=\"1.008\"/> </AtomTypes> <Residues> <Residue name=\"HOH\"> <Atom name=\"H1\" type=\"HT\"/> <Atom name=\"H2\" type=\"HT\"/> <Atom name=\"O\" type=\"OT\"/> <Bond from=\"0\" to=\"2\"/> <Bond from=\"1\" to=\"2\"/> </Residue> </Residues> <HarmonicBondForce> <Bond class1=\"OW\" class2=\"HW\" length=\"0.09572\" k=\"376560\"/> </HarmonicBondForce> <HarmonicAngleForce> <Angle class1=\"HW\" class2=\"OW\" class3=\"HW\" angle=\"1.82421813418\" k=\"460.24\"/> </HarmonicAngleForce> <NonbondedForce coulomb14scale=\"0.833333\" lj14scale=\"0.5\"> <Atom type=\"OT\" charge=\"-0.0\" sigma=\"0.31983264\" epsilon=\"0.677808\"/> <Atom type=\"HT\" charge=\"0.0\" sigma=\"1\" epsilon=\"0\"/> </NonbondedForce> <MPIDForce coulomb14scale=\"0.833333\" defaultTholeWidth=\"8.0\"> <Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" c0=\"-1.0614\" dX=\"0.0\" dY=\"0.0\" dZ=\"-0.023671684\" qXX=\"0.000150963\" qXY=\"0.0\" qYY=\"0.00008707\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"-0.000238034\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.000000426\" oXYZ=\"0.0\" oYYZ=\"0.000000853\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"-0.000001279\" /> <Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" c0=\"0.5307\" dX=\"0.0\" dY=\"0.0\" dZ=\"0.0\" qXX=\"0.0\" qXY=\"0.0\" qYY=\"0.0\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"0.0\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.0\" oXYZ=\"0.0\" oYYZ=\"0.0\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"0.0\" /> <Polarize type=\"OT\" polarizabilityXX=\"0.00088\" polarizabilityYY=\"0.00088\" polarizabilityZZ=\"0.00088\" thole=\"8.0\"/> <Polarize type=\"HT\" polarizabilityXX=\"0.000\" polarizabilityYY=\"0.000\" polarizabilityZZ=\"0.000\" thole=\"0.0\"/> </MPIDForce> </ForceField> Most of this file sets up bonded terms, which are well described in the OpenMM documentation linked above. When defining the NonbondedForce , note that the charges are defined as zero; this is because all electrostatic terms are to be handled by the MPIDForce . The MPIDForce does not handle Lennard-Jones (LJ) terms, so these are still processed by the NonbondedForce , which can also use particle mesh Ewald (PME) to compute the LJ terms effectively without cutoffs. The section defining the MPIDForce terms looks like this: <MPIDForce coulomb14scale=\"0.833333\" defaultTholeWidth=\"8.0\"> <Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" c0=\"-1.0614\" dX=\"0.0\" dY=\"0.0\" dZ=\"-0.023671684\" qXX=\"0.000150963\" qXY=\"0.0\" qYY=\"0.00008707\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"-0.000238034\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.000000426\" oXYZ=\"0.0\" oYYZ=\"0.000000853\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"-0.000001279\" /> <Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" c0=\"0.5307\" dX=\"0.0\" dY=\"0.0\" dZ=\"0.0\" qXX=\"0.0\" qXY=\"0.0\" qYY=\"0.0\" qXZ=\"0.0\" qYZ=\"0.0\" qZZ=\"0.0\" oXXX=\"0.0\" oXXY=\"0.0\" oXYY=\"0.0\" oYYY=\"0.0\" oXXZ=\"0.0\" oXYZ=\"0.0\" oYYZ=\"0.0\" oXZZ=\"0.0\" oYZZ=\"0.0\" oZZZ=\"0.0\" /> <Polarize type=\"OT\" polarizabilityXX=\"0.00088\" polarizabilityYY=\"0.00088\" polarizabilityZZ=\"0.00088\" thole=\"8.0\"/> <Polarize type=\"HT\" polarizabilityXX=\"0.000\" polarizabilityYY=\"0.000\" polarizabilityZZ=\"0.000\" thole=\"0.0\"/> </MPIDForce> The global coulomb14scale parameter controls the scale factor applied to interactions that are topologically three bonds apart, and defaults to 1 (the correct value for MPID) if omitted. The defaultTholeWidth parameter is the [Thole damping] (technical.md#thole-damping) parameter that's applied to particles whose interaction is not neglected due to topological reasons. Multipoles are defined by providing orientation rules, defining their orientation with respect to \"anchor\" atoms within the same system and the syntax follows the conventions used in the AMOEBA force field. For example, Multipole type=\"OT\" kz=\"-HT\" kx=\"-HT\" defines a multipole on the OT atom, whose z direction is defined as the bisector of the two HT atoms directly connected to it, with the \\(x\\) direction defined by the plane containing both HT . The Multipole type=\"HT\" kz=\"OT\" kx=\"HT\" similarly defines a multipole on HT , whose local z axis is defined by its bond to the OT atom; the \\(x\\) axis is then defined by the plane containing the other HT atom. The c0 entry defines the charge (in \\(e\\) ), while dX defines the \\(x\\) component of the dipole in \\(e/nm\\) , etc. . Multipoles up to octopoles are supported, and any values omitted are assumed to be zero. The Polarize tag is optional and is used to define a given atom as polarizable. The \\(xx\\) , \\(yy\\) and \\(zz\\) elements of the polarizability tensor should be specified individually, in the axis system used to define the multipoles described above. If all three components of the polarizability tensor are equal, the polarizability is isotropic and the orientation rules are irrelevant. The Thole damping parameter, detailed here is a unitless parameter used to dampen topologically excluded interactions between pairs of induced dipoles if the chosen solver considers them.","title":"The XML file"},{"location":"running/#creating-a-system","text":"With the appropriate XML-formatted force field in hand, setting up a simulation follows the standard OpenMM approach . The createSystem() function from the ForceField class, which is used to build the system obeys all of the usual arguments for controlling constraint algorithms, hydrogen mass repartitioning, cutoffs, etc. . For MPIDForce , the defaultTholeWidth and coulomb14scale arguments may be provided, overriding any values that may be present in the XML parameter file described above. The polarization argument is used to control the polarization solver .","title":"Creating a System"},{"location":"technical/","text":"Polarization The induced dipoles are the solution to the \\(3N\\times3N\\) system of equations \\[ \\boldsymbol{\\mu}_\\mathrm{ind} = \\mathbf{T}^{-1} \\mathbf{E} \\] where the electric field due to fixed multipoles is \\(\\mathbf{E}\\) and the coupling matrix \\[ \\mathbf{T} = \\boldsymbol{\\alpha}^{-1} + \\boldsymbol{\\tau} \\] is given by the inverse of the diagonal matrix of atomic polarizabilities and the off-diagonal matrix that couples pairs of induced dipoles. When generating the permanent field \\(\\mathbf{E}\\) , topologically excluded (1-2 and 1-3) interactions are neglected, and any 1-4 interactions are scaled, if requested. All pairs of induced dipoles are allowed to interact, which is a key feature of the damping procedure described below. Solvers A few solvers are implemented for evaluating the induced dipoles, which we will briefly discuss. These can be selected by passing the appropriate string to the polarization argument of createSystem() . Direct Solver The simplest \"direct\" solver simply uses the approximation \\[ \\mathbf{T} \\approx \\boldsymbol{\\alpha}^{-1} \\] which effectively removes the mutual interaction between induced dipoles. Because \\(\\boldsymbol{\\alpha}\\) is diagonal, it is trivially invertible and the solution is fully analytic. As a result, the energies and forces are rigorously consistent and integration can be performed exactly as for conventional fixed point charges. However, this simplicity comes at the expense of the quality of the description of the electrostatics. Mutual Solver The \"mutual\" solver keeps the interaction between induced dipoles, making \\(\\mathbf{T}\\) difficult to invert. The induced dipole equations are solved iteratively, with the convergence accelerated by the direct inversion of the iterative subspace (DIIS) technique. Because the coupling between dipoles is present this is the most accurate method, but it is also the most costly due to the need for multiple iterations to solve the equations. While it might be tempting for to lower the convergence criterion to save time, this will lead to inconsistencies in the energies and forces, and runaway heating (or cooling) of the microcanonical ensemble will result. We recommend converging the equation to at least \\(10^{-4}\\) if using this solver; the convergence is controlled by the mutualInducedTargetEpsilon argument to createSystem() , with a default value of \\(10^{-5}\\) . Extrapolated Solver Combining the strengths of both approaches, the \\(n\\) th order Optimized Perturbation Theory OPTn solver treats the induced dipole coupling matrix as a small perturbation to the \"direct\" model, leading to a power series expansion that can be truncated at any order. Some empirical tuning yields the OPT \\(n\\) family of methods. At zeroth order, the \"direct\" solution is obtained. Successively increasing the order increases the cost, with each order costing the equivalent of an iteration of the \"mutual\" solver. Unlike loosely converged \"mutual\" solutions, the OPT \\(n\\) solutions have energies and forces that are rigorously consistent at all levels of trunctions. We recommend the third order \"extrapolated\" solver, OPT3, which is the default solver in this plugin. Other levels of OPT solver may be selected by calling the setExtrapolationCoefficients() on the MPIDForce object. Thole Damping If a pair of polarizable particles get too close, they can strongly polarize each other and at some distance this overpolarization will become infinite; this is often refered to as the \"polarization catastrophe\". Thole introduced a clever damping that effectively gives the point dipoles a finite width and removes the singularity responsible for terms blowing up at short range. The density ascribed to MPID's induced dipoles corresponds to Thole's \\(\\rho_1\\) choice (in contrast to AMOEBA, which uses \\(\\rho_2\\) ): \\[ \\rho_1 = \\frac{a^3}{8\\pi}e^{-a u} \\] where \\(a\\) is a unitless width parameter and \\(u\\) is a dimensionless distance. The result of introducing this density is that interactions between a pair of induced dipoles is scaled by a factor \\[ 1 - e^{-a u}(1 + au + \\frac{(a u)^2}{2}). \\] For MPID , the dimensionless distance for a pair of interacting atoms \\(i\\) and \\(j\\) is given by their separation, \\(R_{ij}\\) , and the individual atomic polarizabilities \\(\\alpha_i\\) and \\(\\alpha_j\\) by \\[ u = \\frac{R_{ij}}{\\alpha_i\\alpha_j}. \\] If the polarizability of and atom is anisotropic, the average of the three diagonal tensor elements is used. The dimensionless width parameter \\(a\\) is given a default value that is used for any interaction that is not excluded (1-2, 1-3 and, if coulomb14scale is zero, 1-4 connected pairs); this default value is controlled by the defaultTholeWidth argument to either the XML force field file or createSystem() . The excluded interactions do not contribute to permanent-permenent moment interactions, or to forming the electric field \\(\\mathbf{E}\\) used to define the induced dipoles. For mutual and extrapolated solvers, the induced dipoles are allowed to interact with each other. These interactions are not subject to excluded rules. For pairs that are not excluded due to topology, the defaultTholeWidth parameter is used to define \\(a\\) . For pairs that are excluded due to topology, we use the individual Thole widths defined in the parameter file and define \\(a=a_i + a_j\\) .","title":"Technical Details"},{"location":"technical/#polarization","text":"The induced dipoles are the solution to the \\(3N\\times3N\\) system of equations \\[ \\boldsymbol{\\mu}_\\mathrm{ind} = \\mathbf{T}^{-1} \\mathbf{E} \\] where the electric field due to fixed multipoles is \\(\\mathbf{E}\\) and the coupling matrix \\[ \\mathbf{T} = \\boldsymbol{\\alpha}^{-1} + \\boldsymbol{\\tau} \\] is given by the inverse of the diagonal matrix of atomic polarizabilities and the off-diagonal matrix that couples pairs of induced dipoles. When generating the permanent field \\(\\mathbf{E}\\) , topologically excluded (1-2 and 1-3) interactions are neglected, and any 1-4 interactions are scaled, if requested. All pairs of induced dipoles are allowed to interact, which is a key feature of the damping procedure described below.","title":"Polarization"},{"location":"technical/#solvers","text":"A few solvers are implemented for evaluating the induced dipoles, which we will briefly discuss. These can be selected by passing the appropriate string to the polarization argument of createSystem() .","title":"Solvers"},{"location":"technical/#direct-solver","text":"The simplest \"direct\" solver simply uses the approximation \\[ \\mathbf{T} \\approx \\boldsymbol{\\alpha}^{-1} \\] which effectively removes the mutual interaction between induced dipoles. Because \\(\\boldsymbol{\\alpha}\\) is diagonal, it is trivially invertible and the solution is fully analytic. As a result, the energies and forces are rigorously consistent and integration can be performed exactly as for conventional fixed point charges. However, this simplicity comes at the expense of the quality of the description of the electrostatics.","title":"Direct Solver"},{"location":"technical/#mutual-solver","text":"The \"mutual\" solver keeps the interaction between induced dipoles, making \\(\\mathbf{T}\\) difficult to invert. The induced dipole equations are solved iteratively, with the convergence accelerated by the direct inversion of the iterative subspace (DIIS) technique. Because the coupling between dipoles is present this is the most accurate method, but it is also the most costly due to the need for multiple iterations to solve the equations. While it might be tempting for to lower the convergence criterion to save time, this will lead to inconsistencies in the energies and forces, and runaway heating (or cooling) of the microcanonical ensemble will result. We recommend converging the equation to at least \\(10^{-4}\\) if using this solver; the convergence is controlled by the mutualInducedTargetEpsilon argument to createSystem() , with a default value of \\(10^{-5}\\) .","title":"Mutual Solver"},{"location":"technical/#extrapolated-solver","text":"Combining the strengths of both approaches, the \\(n\\) th order Optimized Perturbation Theory OPTn solver treats the induced dipole coupling matrix as a small perturbation to the \"direct\" model, leading to a power series expansion that can be truncated at any order. Some empirical tuning yields the OPT \\(n\\) family of methods. At zeroth order, the \"direct\" solution is obtained. Successively increasing the order increases the cost, with each order costing the equivalent of an iteration of the \"mutual\" solver. Unlike loosely converged \"mutual\" solutions, the OPT \\(n\\) solutions have energies and forces that are rigorously consistent at all levels of trunctions. We recommend the third order \"extrapolated\" solver, OPT3, which is the default solver in this plugin. Other levels of OPT solver may be selected by calling the setExtrapolationCoefficients() on the MPIDForce object.","title":"Extrapolated Solver"},{"location":"technical/#thole-damping","text":"If a pair of polarizable particles get too close, they can strongly polarize each other and at some distance this overpolarization will become infinite; this is often refered to as the \"polarization catastrophe\". Thole introduced a clever damping that effectively gives the point dipoles a finite width and removes the singularity responsible for terms blowing up at short range. The density ascribed to MPID's induced dipoles corresponds to Thole's \\(\\rho_1\\) choice (in contrast to AMOEBA, which uses \\(\\rho_2\\) ): \\[ \\rho_1 = \\frac{a^3}{8\\pi}e^{-a u} \\] where \\(a\\) is a unitless width parameter and \\(u\\) is a dimensionless distance. The result of introducing this density is that interactions between a pair of induced dipoles is scaled by a factor \\[ 1 - e^{-a u}(1 + au + \\frac{(a u)^2}{2}). \\] For MPID , the dimensionless distance for a pair of interacting atoms \\(i\\) and \\(j\\) is given by their separation, \\(R_{ij}\\) , and the individual atomic polarizabilities \\(\\alpha_i\\) and \\(\\alpha_j\\) by \\[ u = \\frac{R_{ij}}{\\alpha_i\\alpha_j}. \\] If the polarizability of and atom is anisotropic, the average of the three diagonal tensor elements is used. The dimensionless width parameter \\(a\\) is given a default value that is used for any interaction that is not excluded (1-2, 1-3 and, if coulomb14scale is zero, 1-4 connected pairs); this default value is controlled by the defaultTholeWidth argument to either the XML force field file or createSystem() . The excluded interactions do not contribute to permanent-permenent moment interactions, or to forming the electric field \\(\\mathbf{E}\\) used to define the induced dipoles. For mutual and extrapolated solvers, the induced dipoles are allowed to interact with each other. These interactions are not subject to excluded rules. For pairs that are not excluded due to topology, the defaultTholeWidth parameter is used to define \\(a\\) . For pairs that are excluded due to topology, we use the individual Thole widths defined in the parameter file and define \\(a=a_i + a_j\\) .","title":"Thole Damping"}]}